<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵守恒</title>
  
  <subtitle>个人技术博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-25T06:43:45.437Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>赵守恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端应知应会</title>
    <link href="http://example.com/2024/06/03/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/"/>
    <id>http://example.com/2024/06/03/%E5%89%8D%E7%AB%AF%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A/</id>
    <published>2024-06-03T07:11:41.000Z</published>
    <updated>2024-07-25T06:43:45.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端应知应会"><a href="#前端应知应会" class="headerlink" title="前端应知应会"></a>前端应知应会</h1><h2 id="1-块元素，行内元素，行内块元素什么区别？"><a href="#1-块元素，行内元素，行内块元素什么区别？" class="headerlink" title="1.块元素，行内元素，行内块元素什么区别？"></a>1.块元素，行内元素，行内块元素什么区别？</h2><p>用于描述HTML元素在页面布局中显示的三种不同布局。</p><p><em>块元素独占一行，可以设置宽高；行内元素与其他行内元素在同一行显示，不能直接设置宽高；行内块元素结合了二者的特点，可以设置宽高且与其他行内元素在同一行显示。</em></p><h3 id="块元素-Block-level-elements"><a href="#块元素-Block-level-elements" class="headerlink" title="块元素(Block-level elements)"></a>块元素(Block-level elements)</h3><ul><li>块元素会独占一行，在新的一行开始显示</li><li>可以设置宽度(width)以及高度(height)</li><li>包括：<code>&lt;div&gt;</code> <code>&lt;p&gt;</code> <code>&lt;h1&gt;到&lt;h6&gt;</code> <code>&lt;ul&gt;</code> <code>&lt;ol&gt;</code> <code>&lt;li&gt;</code> <code>&lt;table&gt;</code>等</li><li>默认情况下，块元素的宽度为其父元素的100%</li></ul><h3 id="行内元素-lnline-elements"><a href="#行内元素-lnline-elements" class="headerlink" title="行内元素(lnline elements)"></a>行内元素(lnline elements)</h3><ul><li>行内元素不会独占一行，与其他行内元素在同一行显示，如果宽度不足以容纳则换行显示</li><li>不能直接设置宽度(width)和高度(height)，尺寸由内容决定</li><li>包括：<code>&lt;span&gt;</code> <code>&lt;a&gt;</code> <code>&lt;img&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;u&gt;</code> <code>&lt;em&gt;</code> <code>&lt;strong&gt;</code>等</li><li>可以设置水平边距(margin-left &amp; margin-right)和垂直边距(margin-top &amp; margin-bottom)，垂直边距不会影响其他行内元素的位置</li></ul><h3 id="行内块元素-lnline-block-elements"><a href="#行内块元素-lnline-block-elements" class="headerlink" title="行内块元素(lnline-block elements):"></a>行内块元素(lnline-block elements):</h3><ul><li>不会独占一行可以与其他行内块&#x2F;行内元素在同一行显示</li><li>行内块元素可以设置宽度(width)和高度(height)</li><li>可以设置水平边距(margin-left &amp; margin-right)和垂直边距(margin-top &amp; margin-bottom)，垂直边距会影响其他行内块元素的位置</li><li>可以解决某些页面布局问题，例如：在一行内显示多个具有不同宽度的元素</li><li>将元素设置为行内块元素，通过CSS属性：<code>display: inline-block</code></li></ul><h2 id="2-localstorage，sessionstorage和cookie的区别？"><a href="#2-localstorage，sessionstorage和cookie的区别？" class="headerlink" title="2.localstorage，sessionstorage和cookie的区别？"></a>2.localstorage，sessionstorage和cookie的区别？</h2><p><code>localStorage</code>、<code>sessionStorage</code> 和 <code>Cookie</code> 都是用于在客户端存储数据的技术</p><p><em><code>localStorage</code> 和 <code>sessionStorage</code> 主要用于在客户端临时存储大量数据，而 <code>Cookie</code> 可用于在客户端和服务器之间传递少量数据，并进行用户识别等操作。在选择存储方案时，需要根据实际需求和使用场景来决定使用哪种技术。</em></p><h3 id="存储期限："><a href="#存储期限：" class="headerlink" title="存储期限："></a>存储期限：</h3><ul><li><code>localStorage</code>：数据可以永久存储在客户端，直到用户主动删除或通过JavaScript代码删除。</li><li><code>sessionStorage</code>：数据仅在当前浏览器会话期间有效，当页面会话结束（例如关闭浏览器标签页或窗口）时，数据会被清除。</li><li><code>Cookie</code>：数据存储期限取决于设置的过期时间（<code>expires</code> 属性）。在过期时间之前，数据会一直保留在客户端；一旦过期，数据将被删除。如果没有设置过期时间，<code>Cookie</code> 会话级别的，关闭浏览器标签页或窗口后失效。</li></ul><h3 id="存储空间："><a href="#存储空间：" class="headerlink" title="存储空间："></a>存储空间：</h3><ul><li><code>localStorage</code> 和 <code>sessionStorage</code>：不同浏览器对存储空间大小的限制不同，通常为5MB左右。</li><li><code>Cookie</code>：单个 <code>Cookie</code> 大小限制为4KB（不同浏览器可能略有差异），每个域名下最多可存储的 <code>Cookie</code> 数量也有限制（通常为20个左右）。</li></ul><h3 id="数据共享："><a href="#数据共享：" class="headerlink" title="数据共享："></a>数据共享：</h3><ul><li><code>localStorage</code> 和 <code>sessionStorage</code>：数据仅在当前浏览器窗口或标签页中可用，不同窗口或标签页之间的数据是隔离的。</li><li><code>Cookie</code>：数据可以在同一域名下的不同窗口或标签页之间共享。如果设置了 <code>Cookie</code> 的 <code>domain</code> 属性，数据还可以在不同子域名间共享。</li></ul><h3 id="安全性："><a href="#安全性：" class="headerlink" title="安全性："></a>安全性：</h3><ul><li><code>localStorage</code> 和 <code>sessionStorage</code>：数据容易受到跨站脚本攻击（XSS）的影响，攻击者可以通过脚本窃取或篡改数据。</li><li><code>Cookie</code>：可以设置 <code>Secure</code> 属性以仅在HTTPS连接下传输数据，降低被截获的风险。还可以设置 <code>HttpOnly</code> 属性，使 <code>Cookie</code> 不能通过JavaScript访问，进一步降低XSS攻击的风险。</li></ul><h3 id="与服务器交互："><a href="#与服务器交互：" class="headerlink" title="与服务器交互："></a>与服务器交互：</h3><ul><li><code>localStorage</code> 和 <code>sessionStorage</code>：数据仅存储在客户端，不会随HTTP请求发送到服务器。</li><li><code>Cookie</code>：数据会随每个HTTP请求发送到服务器，服务器可以根据 <code>Cookie</code> 进行用户识别、会话管理等操作。</li></ul><h2 id="3-SEO优化是什么？"><a href="#3-SEO优化是什么？" class="headerlink" title="3.SEO优化是什么？"></a>3.SEO优化是什么？</h2><p>SEO优化，即搜索引擎优化，是一种通过优化网站内容和结构，使其更符合搜索引擎排名算法，从而提高网站在搜索引擎结果页面(SERP)中的自然排名的技术手段。简单来说，SEO的目标就是让更多的人在搜索相关关键词时，能够更容易地找到你的网站。</p><h3 id="SEO优化的核心组成部分"><a href="#SEO优化的核心组成部分" class="headerlink" title="SEO优化的核心组成部分"></a>SEO优化的核心组成部分</h3><ul><li>站内优化：包括内容优化、关键词布局、网站结构调整、代码优化等。</li><li>站外优化：通过外部手段提升网站权重，如外链建设、社交媒体推广等。</li></ul><h3 id="SEO优化的实践方法"><a href="#SEO优化的实践方法" class="headerlink" title="SEO优化的实践方法"></a>SEO优化的实践方法</h3><ul><li>关键词研究和选择：使用关键词研究工具，分析竞争对手，关注用户意图。</li><li>内容优化：关键词合理布局，撰写高质量内容，保持内容更新。</li><li>技术优化：提升网站速度，移动端优化，确保网站安全，优化网站结构。</li><li>外部链接建设：发布高质量内容，进行内容推广，参与行业活动。</li><li>监测和分析：使用分析工具监测网站数据，定期审查网站，调整优化策略。</li></ul><h3 id="SEO优化的重要性"><a href="#SEO优化的重要性" class="headerlink" title="SEO优化的重要性"></a>SEO优化的重要性</h3><p>SEO优化的目的是提高网站的可见性，增加有质量的流量，从而最终提升业务的转化率。一个成功的SEO策略通常需要站内优化和站外优化的共同努力，以确保网站能够在搜索引擎中获得良好的排名。</p><h2 id="4-link和-import的用法和区别："><a href="#4-link和-import的用法和区别：" class="headerlink" title="4.link和@import的用法和区别："></a>4.link和@import的用法和区别：</h2><p><em>尽管 <code>link</code> 和 <code>@import</code> 都可以用于引入外部CSS文件，但在实际应用中，推荐使用 <code>link</code> 标签，因为它具有更好的性能、兼容性和灵活性。</em></p><h3 id="link-用法"><a href="#link-用法" class="headerlink" title="link 用法"></a>link 用法</h3><p><code>link</code> 主要用于在HTML文档的<code>&lt;head&gt;</code>部分引入外部CSS文件。基本语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>rel=&quot;stylesheet&quot;</code> 表示链接的关系类型为样式表。</li><li><code>href=&quot;styles.css&quot;</code> 指定外部CSS文件的路径。</li></ul><h3 id="import-用法"><a href="#import-用法" class="headerlink" title="@import 用法"></a>@import 用法</h3><p><code>@import</code> 用于在CSS文件中引入另一个CSS文件。基本语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> url(<span class="string">&quot;styles.css&quot;</span>);</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;styles.css&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>url(&quot;styles.css&quot;)</code> 或直接 <code>&quot;styles.css&quot;</code> 指定要引入的外部CSS文件的路径。</li></ul><h3 id="link-和-import-的区别"><a href="#link-和-import-的区别" class="headerlink" title="link 和 @import 的区别"></a>link 和 @import 的区别</h3><ol><li><strong>引入方式</strong>：<code>link</code> 是在HTML文档中使用标签引入外部CSS文件，而 <code>@import</code> 是在CSS文件中使用语句引入另一个CSS文件。</li><li><strong>加载顺序</strong>：<code>link</code> 标签按照它们在HTML文档中出现的顺序加载CSS文件，而使用 <code>@import</code> 导入的CSS文件可能会在其他内容之后加载，这可能导致页面渲染时的闪烁现象。</li><li><strong>性能</strong>：由于 <code>@import</code> 可能导致额外的HTTP请求和延迟加载，因此使用 <code>link</code> 标签通常具有更好的性能。</li><li><strong>浏览器兼容性</strong>：<code>@import</code> 在较旧的浏览器（如IE4和IE5）中具有较好的兼容性，而 <code>link</code> 标签在所有现代浏览器中都得到了支持。</li><li><strong>元数据</strong>：<code>link</code> 标签可以包含更多的元数据，例如 <code>title</code>、<code>media</code> 和 <code>charset</code> 等属性，这使得它具有更丰富的功能。</li><li><strong>可访问性</strong>：<code>link</code> 标签通常被认为在可访问性方面具有优势，因为它允许搜索引擎和其他辅助技术更好地理解链接的目的。</li><li><strong>动态样式切换</strong>：通过JavaScript操作DOM，可以动态地添加或移除 <code>link</code> 标签来切换不同的样式表，而使用 <code>@import</code> 则需要重新加载整个CSS文件。</li></ol><h2 id="5-讲讲flex布局"><a href="#5-讲讲flex布局" class="headerlink" title="5.讲讲flex布局"></a>5.讲讲flex布局</h2><p>Flex布局（Flexible Box Layout），也称为Flexbox（弹性盒布局），旨在提供一种简单而灵活的方式来构建现代网页布局。它的目标是解决传统布局方式在构建复杂布局时的限制和不足，特别是在响应式设计中的应用。</p><h3 id="Flex布局的基本原理"><a href="#Flex布局的基本原理" class="headerlink" title="Flex布局的基本原理"></a>Flex布局的基本原理</h3><p>Flex布局通过给父容器添加 <code>display: flex</code>属性，使得子元素能够灵活地排列和对齐。它涉及到两根轴线：主轴和交叉轴。主轴是Flex容器的主要方向，可以是水平或垂直，由 <code>flex-direction</code>属性定义。交叉轴垂直于主轴，由 <code>justify-content</code>和 <code>align-items</code>属性控制子元素在主轴和交叉轴上的对齐方式。</p><h3 id="Flex布局的优势"><a href="#Flex布局的优势" class="headerlink" title="Flex布局的优势"></a>Flex布局的优势</h3><ul><li><strong>强大的自适应能力</strong>：Flex布局能够自动调整子元素的大小以适应容器的大小，实现响应式设计。</li><li><strong>灵活性高</strong>：通过简单的属性设置，可以实现多种布局效果，如水平居中、垂直居中、等高列布局等。</li><li><strong>易于上手</strong>：相比于其他布局方式，Flex布局的规则更直观，更容易实现复杂的布局需求。</li></ul><h3 id="Flex布局的缺点"><a href="#Flex布局的缺点" class="headerlink" title="Flex布局的缺点"></a>Flex布局的缺点</h3><ul><li><strong>浏览器兼容性</strong>：虽然大多数现代浏览器都支持Flex布局，但在一些较旧的浏览器中可能会遇到兼容性问题，特别是那些不支持CSS3的浏览器。</li></ul><h3 id="Flex布局的基本属性"><a href="#Flex布局的基本属性" class="headerlink" title="Flex布局的基本属性"></a>Flex布局的基本属性</h3><ul><li><code>flex-direction</code>：定义主轴的方向。</li><li><code>justify-content</code>：设置子元素在主轴上的对齐方式。</li><li><code>align-items</code>：设置子元素在交叉轴上的对齐方式。</li><li><code>flex-wrap</code>：定义子元素是否换行。</li><li><code>align-content</code>：当Flex项目在交叉轴上有多余空间时，控制多行或多列的对齐方式。</li></ul><h2 id="6-盒模型：标准盒模型，怪异盒模型"><a href="#6-盒模型：标准盒模型，怪异盒模型" class="headerlink" title="6.盒模型：标准盒模型，怪异盒模型"></a>6.盒模型：标准盒模型，怪异盒模型</h2><h3 id="盒模型："><a href="#盒模型：" class="headerlink" title="盒模型："></a>盒模型：</h3><p>盒模型是CSS技术所使用的一种思维模型，它是将网页设计页面中的内容元素看作一个个装了东西的矩形盒子。<br>在盒模型中，内容部分指的是盒子里装的东西，也就是HTML标记中的元素本身。内边距部分是为了保护内容而设置的填充物，它位于内容和边框之间。边框部分就是盒子本身的壳，也就是HTML中的<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;li&gt;</code>等元素的外边框。外边距部分则是多个盒子之间排放时的空隙。<br>盒模型主要是针对页面布局的时候来使用，它规范了页面中所有元素的一个布局规范是由外向内进行布局。盒模型由外向内分别是：外边距、边框、内边距和内容。这种盒子模型是W3C的标准盒子模型，在大多数浏览器上都适用。</p><h3 id="怪异盒模型："><a href="#怪异盒模型：" class="headerlink" title="怪异盒模型："></a>怪异盒模型：</h3><p>怪异盒模型（或称为IE盒模型），这种模型主要表现在IE内核的浏览器上。两种模式可以通过box-sizing的方法进行转换。box-sizing中比较常用的两个属性值为content-box和border-box，它可以改变盒子模型的解析计算模式。在content-box模式下，元素的width和height属性值指的是内容区域（content）的宽度和高度，而padding和border则分别对应内边距和边框的宽度和高度。<br>因此，元素的实际宽度为content的宽度+左右内边距+左右边框；元素的实际高度为content的高度+上下内边距+上下边框。</p><p>而在border-box模式下，元素的width和height属性值指的是包含内容区、内边距（padding）和边框（border）的宽度和高度。这意味着，给元素设置width和height时，实际已经把padding和border的宽度考虑在内了。这种模式可以简化很多布局计算，使得盒子的总宽度和总高度更加直观可控。</p><h3 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h3><p>‌盒模型和怪异盒模型的主要区别在于‌<code>width</code>和‌<code>height</code>属性的应用范围不同。</p><p>盒模型主要由四个部分组成：‌margin（外边距）、‌border（边框）、‌padding（内边距）和‌content（内容）。<br>标准盒模型中，width和height属性仅包含content部分的尺寸，而怪异盒模型中，width和height属性则包括了content、padding和border的尺寸。这意味着在标准盒模型中，当你改变元素的宽度和高度时，只影响content部分，而在怪异盒模型中，改变的是content、padding和border的总和。<br>此外，通过修改元素的box-sizing属性，可以在这两种盒模型之间切换。设置box-sizing: border-box;将使元素采用怪异盒模型，而设置box-sizing: content-box;则使元素采用标准盒模型。这种灵活性使得开发者可以根据需要选择最适合的盒模型来布局和设计页面元素</p><h2 id="7-float是在css中什么作用？"><a href="#7-float是在css中什么作用？" class="headerlink" title="7.float是在css中什么作用？"></a>7.float是在css中什么作用？</h2><p><code>float</code>是CSS中的一个属性，它的主要作用是使元素脱离正常的文档流，并浮动到其父容器的左侧或右侧。浮动元素仍然会占据一定的空间，但它们会从文档的普通流中移出，不会影响其他元素的布局。<br>当一个元素被设置为浮动时，它会向左或向右浮动，直到遇到其前一个浮动元素、父容器的边缘或者另一个浮动元素为止。浮动元素周围的空间会被其他元素填充，而不是像块级元素那样独占一行。<br><em><code>float</code>属性在CSS中的作用是使元素脱离正常的文档流，并允许它们向左或向右浮动，从而实现特定的布局效果。</em></p><h3 id="float属性有以下几个可选值："><a href="#float属性有以下几个可选值：" class="headerlink" title="float属性有以下几个可选值："></a><code>float</code>属性有以下几个可选值：</h3><ol><li><code>left</code>：元素向左浮动。</li><li><code>right</code>：元素向右浮动。</li><li><code>none</code>：元素不浮动，这是默认值。</li></ol><h3 id="浮动元素的一些特点："><a href="#浮动元素的一些特点：" class="headerlink" title="浮动元素的一些特点："></a>浮动元素的一些特点：</h3><ul><li>浮动元素会脱离正常的文档流，不会影响其他元素的布局。</li><li>浮动元素之间不会相互影响，它们会各自独立地浮动。</li><li>浮动元素会形成BFC（块级格式化上下文），这意味着浮动元素内部和外部的布局规则会有所不同。</li><li>浮动元素可能会导致父元素高度塌陷，即父元素的高度变为0，因为浮动元素不再参与父元素高度的撑开。为了解决这个问题，可以使用<code>clear</code>属性清除浮动，或者给父元素添加一个空的块级元素作为占位符。</li></ul><h2 id="8-CSS的选择器，以及CSS3新增的选择器，并且他们的优先级"><a href="#8-CSS的选择器，以及CSS3新增的选择器，并且他们的优先级" class="headerlink" title="8.CSS的选择器，以及CSS3新增的选择器，并且他们的优先级"></a>8.CSS的选择器，以及CSS3新增的选择器，并且他们的优先级</h2><h3 id="CSS-选择器："><a href="#CSS-选择器：" class="headerlink" title="CSS 选择器："></a>CSS 选择器：</h3><ol><li><strong>元素选择器</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: red; &#125;//选择所有的`&lt;<span class="selector-tag">p</span>&gt;`元素，并将它们的文本颜色设置为红色。</span><br></pre></td></tr></table></figure></li><li><strong>类选择器</strong><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.my-<span class="keyword">class</span> &#123; font-size: <span class="number">16</span>px; &#125;<span class="comment">//选择所有具有`my-class`类的元素，并将它们的字体大小设置为16px。</span></span><br></pre></td></tr></table></figure></li><li><strong>ID 选择器</strong><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#my-id</span> &#123; <span class="attribute">background-color</span>: yellow; &#125;<span class="comment">//选择具有`my-id`ID的元素，并将其背景颜色设置为黄色。</span></span><br></pre></td></tr></table></figure></li><li><strong>属性选择器</strong><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span> &#123; <span class="attribute">border</span>: <span class="number">1px</span> solid black; &#125;//选择所有`&lt;<span class="selector-tag">input</span>&gt;`元素，其`type`属性值为`text`，并设置它们的边框样式。</span><br></pre></td></tr></table></figure></li></ol><h3 id="CSS3新增选择器："><a href="#CSS3新增选择器：" class="headerlink" title="CSS3新增选择器："></a>CSS3新增选择器：</h3><ol><li><p><strong>伪类选择器</strong></p><ul><li><code>:hover</code></li><li><code>:active</code></li><li><code>:focus</code></li><li><code>:visited</code></li><li><code>:nth-child()</code></li><li><code>:last-child</code></li><li><code>:first-of-type</code></li><li><code>:last-of-type</code></li><li><code>:only-of-type</code></li><li><code>:nth-last-child()</code></li><li><code>:nth-of-type()</code></li><li><code>:nth-last-of-type()</code></li><li><code>:checked</code></li><li><code>:not()</code></li></ul></li><li><p><strong>结构伪类选择器</strong></p><ul><li><code>:root</code></li><li><code>:empty</code></li><li><code>:target</code></li><li><code>:not()</code></li></ul></li><li><p><strong>其他伪类选择器</strong></p><ul><li><code>:lang()</code></li><li><code>:enabled</code></li><li><code>:disabled</code></li><li><code>:checked</code></li></ul></li><li><p><strong>通用兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> ~ <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: blue; &#125;//选择所有跟在一个`&lt;<span class="selector-tag">h1</span>&gt;`元素后面的`&lt;<span class="selector-tag">p</span>&gt;`元素，并将它们的文本颜色设置为蓝色。</span><br></pre></td></tr></table></figure></li><li><p><strong>相邻兄弟选择器</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: blue; &#125;//选择紧跟在一个`&lt;<span class="selector-tag">h1</span>&gt;`元素后面的`&lt;<span class="selector-tag">p</span>&gt;`元素，并将它们的文本颜色设置为蓝色。</span><br></pre></td></tr></table></figure></li></ol><h3 id="选择器的优先级："><a href="#选择器的优先级：" class="headerlink" title="选择器的优先级："></a>选择器的优先级：</h3><p>CSS中的选择器优先级是按照以下顺序计算的：</p><ol><li><strong>内联样式</strong>（<code>style</code>属性）</li><li><strong>ID 选择器</strong></li><li><strong>类选择器、属性选择器、伪类选择器</strong></li><li><strong>元素选择器、伪元素选择器</strong></li><li>**通配符选择器（<code>*</code>）、子选择器（<code>&gt;</code>）、相邻兄弟选择器（<code>+</code>）、通用兄弟选择器（<code>~</code>）</li></ol><p><em>如果多个选择器具有相同的优先级，那么最后定义的样式将被应用。如果样式规则之间存在冲突，浏览器将使用具有更高优先级的规则来覆盖具有较低优先级的规则。</em></p><h2 id="9-什么叫浅拷贝和深拷贝"><a href="#9-什么叫浅拷贝和深拷贝" class="headerlink" title="9.什么叫浅拷贝和深拷贝"></a>9.什么叫浅拷贝和深拷贝</h2><h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><ul><li><strong>浅拷贝</strong>：创建一个新对象，主要包含对原始对象中数据的引用。只是复制原始对象的顶层数据结构。如果原始对象中的字段是引用类型，复制的是引用而不是对象本身。</li><li><strong>深拷贝</strong>：会创建一个对象，并在新对象中复制原始对象的所有数据。当更新深拷贝对象中的数据时，不会影响原始数据。深拷贝中的“深”表示复制所有嵌套对象。复制对象与原始对象完全独立。</li></ul><h3 id="浅拷贝和深拷贝的区别"><a href="#浅拷贝和深拷贝的区别" class="headerlink" title="浅拷贝和深拷贝的区别"></a>浅拷贝和深拷贝的区别</h3><ul><li><strong>浅拷贝</strong>：只复制原始对象的顶层数据结构，对于引用类型字段，复制的是引用而不是对象本身。因此，原始对象和复制对象之间共享相同的引用，对原始对象的修改会影响到复制对象，但是对于引用类型字段指向的对象本身的修改则不会影响。</li><li><strong>深拷贝</strong>：递归地复制原始对象的所有字段和引用指向的对象，不仅仅是复制引用本身，对新对象所做的修改不会影响到原始对象，因为它们拥有彼此独立的副本。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>浅拷贝</strong>：通常用于创建简单的数据副本</li><li><strong>深拷贝</strong>：则通常用于创建完全独立的对象，以防止修改原始对象或副本的行为会互相影响。</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li><strong>浅拷贝</strong>：可以使用扩展运算符(<code>...</code>)或<code>Object.assign()</code>方法。</li><li><strong>深拷贝</strong>：可以通过递归方式实现，或者使用第三方库如<code>lodash</code>的<code>cloneDeep</code>方法。</li></ul><h2 id="10-keep-alive的作用是什么？user-agent的作用是什么？"><a href="#10-keep-alive的作用是什么？user-agent的作用是什么？" class="headerlink" title="10.keep-alive的作用是什么？user-agent的作用是什么？"></a>10.keep-alive的作用是什么？user-agent的作用是什么？</h2><h3 id="keep-alive-的作用："><a href="#keep-alive-的作用：" class="headerlink" title="keep-alive 的作用："></a>keep-alive 的作用：</h3><p><code>keep-alive</code> 是一个 HTTP&#x2F;1.1 的特性，用于在一个 TCP 连接上进行多个请求&#x2F;响应交换，避免多次建立和关闭连接的时间消耗。</p><ol><li><strong>减少连接建立和关闭的时间</strong>：每次建立一个新的连接都需要经过三次握手，会增加延迟。使用 <code>keep-alive</code>，可以在一个已经建立的连接上进行多次请求&#x2F;响应交换，从而减少了握手的时间消耗。</li><li><strong>减少服务器资源消耗</strong>：频繁地建立和关闭连接会占用更多的服务器资源。<code>keep-alive</code> 可以复用一个已经存在的连接，降低服务器的负载。</li><li><strong>提高网络传输效率</strong>：在一个TCP连接上进行多个请求&#x2F;响应交换可以提高网络传输效率，因为TCP连接一旦建立，就会保持其传输性能。</li></ol><h3 id="user-agent-的作用"><a href="#user-agent-的作用" class="headerlink" title="user-agent 的作用"></a>user-agent 的作用</h3><p><code>User-Agent</code> 是一个 HTTP 请求头，用于标识发出请求的客户端信息。通常包括客户端软件的类型、操作系统、版本等信息。</p><ol><li><strong>辅助服务器进行用户识别</strong>：通过 <code>User-Agent</code>，服务器可以识别出用户使用的设备类型、操作系统以及浏览器等信息。使服务器可以根据用户的设备和浏览器特性提供定制化服务。</li><li><strong>辅助进行网站适配</strong>：服务器可以根据 <code>User-Agent</code> 信息判断客户端设备的屏幕尺寸、分辨率等特性，提高浏览体验。</li><li><strong>辅助进行功能支持判断</strong>：某些情况下，服务器需要根据客户端设备的特性来判断是否支持某些功能。例如，服务器可以通过 <code>User-Agent</code> 来判断客户端是否支持 HTML5 的某些特性。</li></ol><h2 id="11-null和undefined的区别？还有判定方法"><a href="#11-null和undefined的区别？还有判定方法" class="headerlink" title="11.null和undefined的区别？还有判定方法"></a>11.null和undefined的区别？还有判定方法</h2><p><code>null</code> 和 <code>undefined</code> 都是 JavaScript 中表示“空值”或“缺失值”的特殊值</p><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><ol><li><p><strong>意图</strong>：</p><ul><li><code>null</code>：通常表示一个变量被有意地赋予了空值或没有值。开发者可以使用 <code>null</code> 声明一个尚不存在的引用。</li><li><code>undefined</code>：当变量被声明，但尚未赋值时，其默认值为 <code>undefined</code>。还有一些其他情况下可能会遇到 <code>undefined</code>，如访问不存在的对象属性。</li></ul></li><li><p><strong>数据类型</strong>：</p><ul><li><code>null</code> 属于引用类型，表示它是一个指向空引用的指针。</li><li><code>undefined</code> 属于基本类型（虽然在一些语言实现中它可能被视为引用类型）。</li></ul></li><li><p><strong>通过 <code>typeof</code> 运算符进行类型检测</strong>：</p><ul><li>对于 <code>null</code>，使用 <code>typeof</code> 运算符会返回 <code>&quot;object&quot;</code>。</li><li>对于 <code>undefined</code>，使用 <code>typeof</code> 运算符会返回 <code>&quot;undefined&quot;</code>。</li></ul></li></ol><h3 id="判定方法："><a href="#判定方法：" class="headerlink" title="判定方法："></a>判定方法：</h3><h4 id="null"><a href="#null" class="headerlink" title="null:"></a>null:</h4><ol><li>直接比较：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// a 是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>typeof</code> 运算符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="literal">null</span> || <span class="keyword">typeof</span> a === <span class="string">&#x27;object&#x27;</span> &amp;&amp; !a) &#123;</span><br><span class="line">  <span class="comment">// a 是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>typeof null</code> 返回 <code>&#39;object&#39;</code>，因此需要额外的条件来排除空对象引用。<br>3. 使用 <code>Array.includes()</code> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="literal">null</span>].<span class="title function_">includes</span>(a)) &#123;</span><br><span class="line">  <span class="comment">// a 是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用 <code>JSON.stringify()</code></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a) === <span class="string">&#x27;null&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// a 是 null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>JSON.stringify()</code> 可能会因对象属性的顺序问题而产生不同的结果。但在判断 <code>null</code> 的情况下，这通常是一个有效的方法。</p><h4 id="undefined"><a href="#undefined" class="headerlink" title="undefined:"></a>undefined:</h4><ol><li>直接比较<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// a 是 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 <code>typeof</code> 运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="comment">// a 是 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 <code>Array.includes()</code> 方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="literal">undefined</span>].<span class="title function_">includes</span>(a)) &#123;</span><br><span class="line">  <span class="comment">// a 是 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用 <code>Object.values()</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">values</span>(a).<span class="title function_">includes</span>(<span class="literal">undefined</span>)) &#123;</span><br><span class="line">  <span class="comment">// a 是 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>如果变量不是对象,不可使用</li></ol><h2 id="12-什么是JSX？"><a href="#12-什么是JSX？" class="headerlink" title="12.什么是JSX？"></a>12.什么是JSX？</h2><p>JSX（JavaScript XML）是一种在 JavaScript 代码中编写类似 HTML 结构的语法糖，JSX是JavaScript语法扩展，可以让你在JavaScript文件中书写类似HTML的标签。<br>JSX是一种在JavaScript中编写类似HTML的语法糖，常与React等前端库一起使用，以简化UI组件的声明和操作。Babel等工具可以将JSX转换为浏览器可执行的JavaScript代码。</p><h2 id="13-react的生命周期方法有哪些？"><a href="#13-react的生命周期方法有哪些？" class="headerlink" title="13.react的生命周期方法有哪些？"></a>13.react的生命周期方法有哪些？</h2><ol><li><code>constructor(props)</code>：在组件实例化时调用，用于初始化组件状态（state）和绑定事件处理器。此方法是可选的。</li><li><code>static getDerivedStateFromProps(nextProps, prevState)</code>:在组件挂载之前以及每次重新渲染之前调用。用于响应 props 的变化来更新组件状态。此方法是可选的。</li><li><code>render()</code>:每个生命周期方法中唯一必需的方法。负责生成并返回组件的虚拟DOM。此方法不能修改组件状态或直接与DOM交互。</li><li><code>componentDidMount()</code>:在组件挂载到 DOM 之后调用。此时可以安全地进行 DOM 操作、发起网络请求等。</li><li><code>shouldComponentUpdate(nextProps, nextState)</code>:在组件重新渲染之前调用。可以根据条件返回 <code>true</code>（允许渲染）或 <code>false</code>（阻止渲染）来优化性能。此方法是可选的。</li><li><code>static getSnapshotBeforeUpdate(prevProps, prevState)</code>:在组件实际更新（DOM 更新）之前调用。允许你在可能改变之前捕获 DOM 信息（例如滚动位置）。此方法是可选的。</li><li><code>componentDidUpdate(prevProps, prevState, snapshot)</code>:在组件更新后调用。可以执行 DOM 操作、处理网络请求响应等。此方法是可选的。</li><li><code>componentWillUnmount()</code>:在组件从 DOM 中卸载之前调用。用于清理组件（例如取消网络请求、移除 DOM 事件监听器等）。</li><li><code>componentDidCatch(error, info)</code>:在子组件树中的任何组件抛出错误时调用。用于全局错误处理。此方法是可选的。</li><li><code>static getDerivedStateFromError(error)</code>:当子组件树中的任何组件抛出错误时调用。用于渲染备用用户界面。此方法是可选的。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component did mount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextState.<span class="property">count</span> &lt; <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component did update&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Component will unmount&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">          Increment</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="14-什么叫mixin"><a href="#14-什么叫mixin" class="headerlink" title="14.什么叫mixin"></a>14.什么叫mixin</h2><p>它是一种编程模式，允许将可复用的功能以对象的形式分发到其他类中，实现代码的模块化和复用。Mixin是一种提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p><ul><li>应用场景：用于提取组件中的公共逻辑或配置，减少代码冗余，提高代码复用性。</li><li>与继承的区别：Mixin和继承都可以实现代码复用，但Mixin不需要子类继承父类。Mixin更像是将多个类的功能“混合”到一个类中，而继承则是创建一个新的类，它是另一个类的子类。因此它在处理多重继承时更加灵活，避免了继承带来的复杂性。</li><li><pre><code class="javascript">// 定义一个mixinconst myMixin = &#123;  method1() &#123;    console.log(&#39;This is a mixin method.&#39;);  &#125;&#125;;// 使用mixin的类class MyClass extends myMixin &#123;  constructor() &#123;    super();    this.method1(); // 调用mixin中的方法  &#125;&#125;</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端应知应会&quot;&gt;&lt;a href=&quot;#前端应知应会&quot; class=&quot;headerlink&quot; title=&quot;前端应知应会&quot;&gt;&lt;/a&gt;前端应知应会&lt;/h1&gt;&lt;h2 id=&quot;1-块元素，行内元素，行内块元素什么区别？&quot;&gt;&lt;a href=&quot;#1-块元素，行内元素，行内块元素</summary>
      
    
    
    
    
    <category term="前端" scheme="http://example.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的提升</title>
    <link href="http://example.com/2024/05/01/JS%E7%9A%84%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2024/05/01/JS%E7%9A%84%E6%8F%90%E5%8D%87/</id>
    <published>2024-05-01T10:19:21.000Z</published>
    <updated>2024-07-10T01:24:16.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript的提升"><a href="#JavaScript的提升" class="headerlink" title="JavaScript的提升"></a>JavaScript的提升</h1><h2 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h2><p>我们在JavaScript初期的学习过程中，有相当的教科书以及老师会告诉我们JavaScript是由上到下逐行执行的，这在大多数情况下都是正确的，但是凡事都有例外，如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">var a<span class="comment">;</span></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面的代码，很多人可能会先入为主认为是undefined，因为<code>var a</code>声明在<code>a = 2</code>之后，自然而然会认为变量被重新赋值了，因此认为是undefined，然而事实输出结果是2.<br>再考虑如下代码：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line">var a <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>由上一个代码块表现出来异于自上而下的特性，在这影响下又回回到上一个误区，认为这里的输出为2，还有人会认为这里会报错，然而这个代码块的输出是undefined<br>因此我们此处面临着类似于世界上是先有鸡还是先有蛋的怪圈。</p><h2 id="编译器的影响"><a href="#编译器的影响" class="headerlink" title="编译器的影响"></a>编译器的影响</h2><p>正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。<br>当我们看到<code>var a = 2;</code>时，可能下意识认为这是一个声明，但是JS编译器实质上会将其看成两个声明，即：<code>var a;</code> 和 <code>a=2</code> ,第一个声明是在编译阶段进行的，第二个赋值则在原地等待执行阶段。<br>我们的第一个代码段会这样进行处理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a<span class="comment">;</span></span><br><span class="line"><span class="attribute">a</span> <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>第一部分是编译，第二部分是执行。<br>我们的第二个代码段会这样进行处理：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a<span class="comment">;</span></span><br><span class="line">console.log(a)<span class="comment">;</span></span><br><span class="line"><span class="attribute">a</span> <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br></pre></td></tr></table></figure><p>这样的过程，就像变量和函数声明把它们从代码出现的位置移动到了最上面。这个过程被叫做提升。</p><p><strong>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成相当严重的破坏</strong></p><h2 id="对函数的声明"><a href="#对函数的声明" class="headerlink" title="对函数的声明"></a>对函数的声明</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(a);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面对于变量的提升，相比很容易就能联想到这里的函数<code>foo()</code>应该也是能提升的，因此第一行中的调用可以正常执行。<br>值得注意的是，每一个作用于都会进行提升操作，就如我们正在讨论的<code>foo()</code>函数内部也对<code>var a</code>进行提升，当然不是提升到整个程序的最上方，更贴切的说这里的提升是限定在作用域内的。因此会被理解为下面的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(a);<span class="comment">//undefined</span></span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><strong>实践是检验真理的唯一标准，没有任何教科书会确保自己不会出错，实践出真知！</strong><br>可以看到上面代码块中，函数声明被提升了，但是函数表达式却不会被提升。再看下面的代码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();<span class="comment">//这里不是ReferenceError,而是TypeError!</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中的变量标识符<code>foo()</code>，被提升分配给了所在作用域（此处是全局作用域），所以并不导致ReferenceError，但是foo()并没有被赋值，因为这里是函数表达式而不是函数声明。此处foo()调用了undefined，从而导致非法操作，因此报错TypeError。<br>即便是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>();</span><br><span class="line"><span class="built_in">bar</span>():</span><br><span class="line">var foo = function <span class="built_in">bar</span>()&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码经过提升后，实际会被理解为以下形式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo<span class="comment">;</span></span><br><span class="line">foo()<span class="comment">;</span></span><br><span class="line">bar()<span class="comment">;</span></span><br><span class="line"><span class="attribute">foo</span> <span class="operator">=</span> function()&#123;</span><br><span class="line">    var bar <span class="operator">=</span> ...</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps：各位可能对于ReferenceError&#x2F;TypeError的意义不是很明确，因此下面进行补充。</p><h4 id="ReferenceError-TypeError"><a href="#ReferenceError-TypeError" class="headerlink" title="ReferenceError&#x2F;TypeError"></a>ReferenceError&#x2F;TypeError</h4><p><del>这些都是较为基础的知识点，因此这里不会特别详细。</del></p><h5 id="Reference-引用错误"><a href="#Reference-引用错误" class="headerlink" title="Reference(引用错误)"></a>Reference(引用错误)</h5><p>当尝试访问一个未被声明或定义的变量时发生。<br>因为在JavaScript中，必须在使用变量之前声明&#x3D;&gt;var、let、const<br>当然，我们上文也对声明提升问题进行了讨论。</p><h5 id="TypeError-类型错误"><a href="#TypeError-类型错误" class="headerlink" title="TypeError(类型错误)"></a>TypeError(类型错误)</h5><p>当尝试对错误类型的值执行不被允许的操作时发生。通常表明在操作中使用了不兼容的数据类型。</p><h2 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h2><p>经过我们上面的讨论，发现不论是函数声明还是变量声明都会提升。需要补充的是，函数首先被提升然后才是变量，参考如下：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo()   <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的输出是1而不是2。在引擎的理解下，会整理成如下形式：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数声明会被提升到普通变量，比如：<code>var foo</code>尽管出现在<code>function foo()...</code>之前，但是由于是重复的声明，因此被忽略。<br>重复的<code>var</code>声明会被忽略，但出现在后面的函数声明依然可以覆盖前面的，参考下面的代码：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo();  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>（<span class="number">2</span>）；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.<span class="built_in">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个作用域中重复定义是非常糟糕的，可能会导致一些特别奇怪无法预测的问题&#x3D;&gt;这些听起来就是无用的学院派理论，但是非常需要注意。<br><strong>无论如何，光看不练始终是没有用的</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript的提升&quot;&gt;&lt;a href=&quot;#JavaScript的提升&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的提升&quot;&gt;&lt;/a&gt;JavaScript的提升&lt;/h1&gt;&lt;h2 id=&quot;执行顺序问题&quot;&gt;&lt;a href=&quot;#执行顺</summary>
      
    
    
    
    
    <category term="提升" scheme="http://example.com/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>JS及编辑原理</title>
    <link href="http://example.com/2024/04/22/JS%E5%8F%8A%E7%BC%96%E8%BE%91%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/04/22/JS%E5%8F%8A%E7%BC%96%E8%BE%91%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-22T07:16:27.000Z</published>
    <updated>2024-07-07T12:00:46.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS及编辑原理"><a href="#JS及编辑原理" class="headerlink" title="JS及编辑原理"></a>JS及编辑原理</h1><p>即便大家跟喜欢称JS为“解释性语言”，但是事实上它是一门编译语言。不同于传统的编译语言，它不是提前编译的，编译结果也不能在分布式系统中移植。</p><h2 id="传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译："><a href="#传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译：" class="headerlink" title="传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译："></a>传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译：</h2><h3 id="分词-语法分析："><a href="#分词-语法分析：" class="headerlink" title="分词&#x2F;语法分析："></a>分词&#x2F;语法分析：</h3><p>这个过程会把字符串拆分成各个代码块，这些代码块被称为词法单元；如果<strong>空格</strong>在这门语言中有意义的话，也会被视作词法单元。<br>  分词与语法分析的界限在我看来较为模糊，两者之间区别非常微妙晦涩：<br>     在定义上：分词主要关注单词或词形的识别和分类，而语法分析侧重于确定句子中的语法关系和结构。<br>     在应用上：分词通常在语法分析之前进行，为语法分析提供输入；语法分析则使用分词的结果作为输入，并确定单词之间的依存关系和功能关系：<br>     <strong>分词&#x3D;&gt;语法分析&#x3D;&gt;单词之间的依存关系和功能关系</strong></p><h3 id="解析-语法分析："><a href="#解析-语法分析：" class="headerlink" title="解析&#x2F;语法分析："></a>解析&#x2F;语法分析：</h3><p>这个过程是将数组（词法单元流）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树——抽象语法树。</p><h4 id="抽象语法树："><a href="#抽象语法树：" class="headerlink" title="抽象语法树："></a>抽象语法树：</h4><p>抽象语法树(Abstract Syntax Tree,AST)：以树的形式表示程序的语法结构，其中每个节点代表源代码中的一个语法元素，AST是编译器和代码分析工具的核心组件，由于它的存在得以以结构化的方式来表示和理解源代码，便于更佳有效的进行语法检查和优化。<br>ps：这是一个比较抽象的知识点概念，很难具像化的进行描述。</p><h3 id="代码生成："><a href="#代码生成：" class="headerlink" title="代码生成："></a>代码生成：</h3><p>这个过程是指将AST转换成可执行代码的过程被称为代码生成。与语言以及目标平台等息息相关。<br>简单描述的话，就是有某种方法可以将<code>var a = 2</code>的AST转化为一组机械指令，用来创建一个叫做a的变量（包括分配内存等），并且将一个值储存在a中。<br><strong>因此比起只有三个步骤的语言的编译器而言，JS编译器引擎要复杂的多</strong></p><h3 id="JavaScript编译与其他计算机语言的差异化"><a href="#JavaScript编译与其他计算机语言的差异化" class="headerlink" title="JavaScript编译与其他计算机语言的差异化"></a>JavaScript编译与其他计算机语言的差异化</h3><p>JS引擎不会有大量的时间（相较于其他语言的编译器）进行优化，不同于其他语言，JS的编译过程不是发生在构建之前的。JS的编译大部分情况下发生在代码执行前的几微秒（甚至更短）的时间内。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS及编辑原理&quot;&gt;&lt;a href=&quot;#JS及编辑原理&quot; class=&quot;headerlink&quot; title=&quot;JS及编辑原理&quot;&gt;&lt;/a&gt;JS及编辑原理&lt;/h1&gt;&lt;p&gt;即便大家跟喜欢称JS为“解释性语言”，但是事实上它是一门编译语言。不同于传统的编译语言，它不是提前编</summary>
      
    
    
    
    
    <category term="JavaScript编译原理" scheme="http://example.com/tags/JavaScript%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的搭建</title>
    <link href="http://example.com/2024/03/20/Hexo%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2024/03/20/Hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2024-03-20T07:16:27.000Z</published>
    <updated>2024-07-21T01:25:26.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>最近计划搭建自己的博客，于是在CSDN，或是<a href="https://hexo.io/zh-tw/">hexo官网</a>查询搭建方式，发现各个平台都没有一套完整简洁的方法，而且或多或少都会遇见一些难以解决的问题，因此，整理了这一篇文档以供大家参考，用以使用Hexo来搭建大家自己的博客。<br>Hexo使用Markdown来写文章，几秒时间就可以生成静态网页。</p><h2 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h2><p>Hexo是一个基于Node.js的静态博客框架，与Github结合使用，允许用户通过Github Pages<strong>免费</strong>托管和分享博客内容。<br>博客对于程序员来说，不仅仅是一个分享内容的平台，我们通常将开源项目分享在Github上，将学习心得整理在博客上，这里我整理Hexo的搭建方式也是为了方便大家对于Hexo的建立并且作为我分享的第一个文章。<br>我的师傅对我说过，一个程序员，能够在自己学习的历程中，记录下来笔记，写下心得是相当重要的，因此在他的引导下，我以Hexo为平台，分享记录自己相对重要的笔记以及体会。这里撰写内容使用的语言是Markdown，对于md编辑器通常使用Typora、mweb或者vscode，前两者需要收费才能开通全部功能，而vscode则完全免费使用，但是观感上并不如前两者好看以及好用，但是各个平台对于破解版软件的售卖基本毫无顾虑，所以很简单就能买到破解版软件，但是对于程序员来说版权是一个比较敏感的问题，如果没有经济实力可以使用破解版，如果未来发展成功补票上车来对软件开发团队的敬意其实也不无不可。<br>对于md撰写笔记有很多小指令，我后续会写一篇简短的文章来介绍。</p><h3 id="Hexo的安装前提"><a href="#Hexo的安装前提" class="headerlink" title="Hexo的安装前提"></a>Hexo的安装前提</h3><p>安装Hexo非常简单：<br>    Node.js <em>版本不低于10.13，只要稍微注意就行，一般直接安装最新版本</em><br>    Git 对于程序员是经常使用或者说是必须了解的代码托管平台</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>Github主要是以程序员为主的全球最大的代码托管平台，主要作用是保存程序员编写的软件源代码，对于程序员来说Github绝对不陌生 <del>（如果不知道的，去墙角罚站）</del> ，因此这里就不对Github做过多描述了。<br>想要使用Hexo搭建属于自己的博客需要的前提就是要有自己的Github，并且完成通信。<br>所以本文并不对Github的基本使用做出描述，可能后续会写一些文章作为Github的教程。<br>可以点击本文的超链接跳转到Github官网：<a href="https://github.com/">跳转到Github官网</a></p><h4 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h4><p>Node.js的安装较为简单，并且他为大多数平台提供了官方安装程序。<br><a href="https://nodejs.p2hp.com/download/">Node.js下载链接</a><br>目前node.js官网的下载方式已经相当人性化，可以通过官网提供的安装程序进行安装，个人建议安装LTS版本（稳定版）。<br>按照引导的方式安装完成之后，打开终端，输入：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="keyword">node</span> <span class="title">-v</span></span><br></pre></td></tr></table></figure><p>出现版本号即代表安装成功。</p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>如果上述操作都已经完成，那么可以通过npm即可完成Hexo的安装</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><p>结合各个平台在这里出现的问题，我发现这里可能会弹出警告warn缺少权限，那么我们可以在指令前加上sudo，相当于windows中使用管理员权限运行：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure><h4 id="步骤一-hexo-init"><a href="#步骤一-hexo-init" class="headerlink" title="步骤一 hexo init"></a>步骤一 hexo init</h4><p>我们可以通过终端，选定想要将博客所需的文件夹创建的位置，对文档的归类整理相当重要，建议每个人都要养成习惯。<br>macos许多操作需要使用终端指令来完成,这里只需要打开想要下载的位置，并且在终端输入：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> &lt;my_blog  <span class="comment">//这里文件夹的名字可以自己取，下文都用my_blog指代&gt;</span></span><br><span class="line">cd my_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装后，文件下的目录如下所示：<br>_config.yml：网站的配置信息，您可以在此配置大部分的参数。<br>package.json：这里记录了应用程序的信息，对于第三方插件等的应用版本需求等。<br>scaffolds：这是模板文件夹，当创建文章时，Hexo会更需scffolds来创建文件。<br>source：这是资源文件夹，用以存放用户资源（开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略）。<br>themes：主题文件夹，我们可以在官方提供的主题里面挑选自己喜欢的主题，这里由于官网对于Hexo的支持真的可以说成是一坨，不然不会激起我以及我师傅对于Hexo博客的搭建教程，所以大家在应用主题时要注意主题的支持以及需要的第三方插件。</p><h4 id="步骤二-Github"><a href="#步骤二-Github" class="headerlink" title="步骤二 Github"></a>步骤二 Github</h4><p>在Github上创建一个仓库，仓库名为 <strong>账户名.github.io</strong> ，其他为默认选项。</p><h4 id="步骤三-deploy插件"><a href="#步骤三-deploy插件" class="headerlink" title="步骤三 deploy插件"></a>步骤三 deploy插件</h4><p>deploy插件极为重要，必须部署，负责将Hexo生成的静态文件推送到远程服务器，从而实现博客的部署。<br>在博客目录下，敲击命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><h5 id="配置deploy"><a href="#配置deploy" class="headerlink" title="配置deploy"></a>配置<code>deploy</code></h5><p>安装完成后需要在_config.yml中启用并且配置deploy插件，以下是一个基本的配置示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span><span class="params">&lt;repository url&gt;</span></span><br><span class="line"><span class="symbol">  branch:</span><span class="params">&lt;branch&gt;</span></span><br><span class="line"><span class="symbol">  message:</span><span class="params">&lt;commit message&gt;</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>type</code>：指定部署类型，通常为<code>git</code>。</li><li><code>repo</code>：指定远程仓库的URL，例如<code>https://github.com/username/username.github.io.git</code>。</li><li><code>branch</code>：指定部署到的分支，对于GitHub Pages，通常是<code>main</code>或<code>master</code>。</li><li><code>message</code>：指定提交信息，可以是自定义的消息或自动生成的消息。</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>完成以上配置后，可以使用如下命令来使用Hexo博客：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure><p>这个命令会触发<code>deploy</code>插件，将生成的静态文件推送到指定的远程仓库。</p><p><em>不得不说的注意事项：</em></p><ul><li>在部署之前，请确保已经安装了Git，并且配置了正确的SSH密钥。</li><li>如果遇到部署失败的情况，可以检查<code>deploy</code>插件的配置是否正确，或者查看Hexo输出的错误信息进行排查。</li><li>如果需要部署到多个远程仓库，可以在<code>_config.yml</code>文件中配置多个<code>deploy</code>插件实例。</li></ul><p><em>好了，你已经学会了初步制作一个属于自己的博客了，下面开始尝试吧</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;最近计划搭建自己的博客，于是在CSDN，或是&lt;a href=&quot;https://hexo.io/zh-tw/&quot;&gt;hexo官网&lt;</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
