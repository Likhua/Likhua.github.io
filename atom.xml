<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Likhua</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-07-08T01:43:28.239Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>赵守恒</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript的提升</title>
    <link href="http://example.com/2024/05/01/JS%E7%9A%84%E6%8F%90%E5%8D%87/"/>
    <id>http://example.com/2024/05/01/JS%E7%9A%84%E6%8F%90%E5%8D%87/</id>
    <published>2024-05-01T10:19:21.000Z</published>
    <updated>2024-07-08T01:43:28.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript的提升"><a href="#JavaScript的提升" class="headerlink" title="JavaScript的提升"></a>JavaScript的提升</h1><h2 id="执行顺序问题"><a href="#执行顺序问题" class="headerlink" title="执行顺序问题"></a>执行顺序问题</h2><p>我们在JavaScript初期的学习过程中，有相当的教科书以及老师会告诉我们JavaScript是由上到下逐行执行的，这在大多数情况下都是正确的，但是凡事都有例外，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line">var a;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>上面的代码，很多人可能会先入为主认为是undefined，因为<code>var a</code>声明在<code>a = 2</code>之后，自然而然会认为变量被重新赋值了，因此认为是undefined，然而事实输出结果是2.<br>再考虑如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a = 2;</span><br></pre></td></tr></table></figure><p>由上一个代码块表现出来异于自上而下的特性，在这影响下又回回到上一个误区，认为这里的输出为2，还有人会认为这里会报错，然而这个代码块的输出是undefined<br>因此我们此处面临着类似于世界上是先有鸡还是先有蛋的怪圈。</p><h2 id="编译器的影响"><a href="#编译器的影响" class="headerlink" title="编译器的影响"></a>编译器的影响</h2><p>正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。<br>当我们看到<code>var a = 2;</code>时，可能下意识认为这是一个声明，但是JS编译器实质上会将其看成两个声明，即：<code>var a;</code> 和 <code>a=2</code> ,第一个声明是在编译阶段进行的，第二个赋值则在原地等待执行阶段。<br>我们的第一个代码段会这样进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a = 2;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><p>第一部分是编译，第二部分是执行。<br>我们的第二个代码段会这样进行处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 2;</span><br></pre></td></tr></table></figure><p>这样的过程，就像变量和函数声明把它们从代码出现的位置移动到了最上面。这个过程被叫做提升。</p><p><strong>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成相当严重的破坏</strong></p><h2 id="对函数的声明"><a href="#对函数的声明" class="headerlink" title="对函数的声明"></a>对函数的声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo();</span><br><span class="line">function foo()&#123;</span><br><span class="line">console.log(a);</span><br><span class="line">var a = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面对于变量的提升，相比很容易就能联想到这里的函数<code>foo()</code>应该也是能提升的，因此第一行中的调用可以正常执行。<br>值得注意的是，每一个作用于都会进行提升操作，就如我们正在讨论的<code>foo()</code>函数内部也对<code>var a</code>进行提升，当然不是提升到整个程序的最上方，更贴切的说这里的提升是限定在作用域内的。因此会被理解为下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a;</span><br><span class="line">    console.log(a);//undefined</span><br><span class="line">    a = 2;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p><strong>实践是检验真理的唯一标准，没有任何教科书会确保自己不会出错，实践出真知！</strong><br>可以看到上面代码块中，函数声明被提升了，但是函数表达式却不会被提升。再看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo();//这里不是ReferenceError,而是TypeError!</span><br><span class="line">var foo = function bar()&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序中的变量标识符<code>foo()</code>，被提升分配给了所在作用域（此处是全局作用域），所以并不导致ReferenceError，但是foo()并没有被赋值，因为这里是函数表达式而不是函数声明。此处foo()调用了undefined，从而导致非法操作，因此报错TypeError。<br>ps：各位可能对于ReferenceError&#x2F;TypeError的意义不是很明确，因此下面进行补充。</p><h4 id="ReferenceError-TypeError"><a href="#ReferenceError-TypeError" class="headerlink" title="ReferenceError&#x2F;TypeError"></a>ReferenceError&#x2F;TypeError</h4><p><del>这些都是较为基础的知识点，因此这里不会特别详细。</del></p><h5 id="Reference-引用错误"><a href="#Reference-引用错误" class="headerlink" title="Reference(引用错误)"></a>Reference(引用错误)</h5><p>当尝试访问一个未被声明或定义的变量时发生。<br>因为在JavaScript中，必须在使用变量之前声明&#x3D;&gt;var、let、const<br>当然，我们上文也对声明提升问题进行了讨论。</p><h5 id="TypeError-类型错误"><a href="#TypeError-类型错误" class="headerlink" title="TypeError(类型错误)"></a>TypeError(类型错误)</h5><p>当尝试对错误类型的值执行不被允许的操作时发生。通常表明在操作中使用了不兼容的数据类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript的提升&quot;&gt;&lt;a href=&quot;#JavaScript的提升&quot; class=&quot;headerlink&quot; title=&quot;JavaScript的提升&quot;&gt;&lt;/a&gt;JavaScript的提升&lt;/h1&gt;&lt;h2 id=&quot;执行顺序问题&quot;&gt;&lt;a href=&quot;#执行顺</summary>
      
    
    
    
    
    <category term="提升" scheme="http://example.com/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>JS及编辑原理</title>
    <link href="http://example.com/2024/04/22/JS%E5%8F%8A%E7%BC%96%E8%BE%91%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2024/04/22/JS%E5%8F%8A%E7%BC%96%E8%BE%91%E5%8E%9F%E7%90%86/</id>
    <published>2024-04-22T07:16:27.000Z</published>
    <updated>2024-07-07T12:00:46.227Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS及编辑原理"><a href="#JS及编辑原理" class="headerlink" title="JS及编辑原理"></a>JS及编辑原理</h1><p>即便大家跟喜欢称JS为“解释性语言”，但是事实上它是一门编译语言。不同于传统的编译语言，它不是提前编译的，编译结果也不能在分布式系统中移植。</p><h2 id="传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译："><a href="#传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译：" class="headerlink" title="传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译："></a>传统编译语言的流程中，程序中的一段源代码会在执行之前经历三个步骤，统称为编译：</h2><h3 id="分词-语法分析："><a href="#分词-语法分析：" class="headerlink" title="分词&#x2F;语法分析："></a>分词&#x2F;语法分析：</h3><p>这个过程会把字符串拆分成各个代码块，这些代码块被称为词法单元；如果<strong>空格</strong>在这门语言中有意义的话，也会被视作词法单元。<br>  分词与语法分析的界限在我看来较为模糊，两者之间区别非常微妙晦涩：<br>     在定义上：分词主要关注单词或词形的识别和分类，而语法分析侧重于确定句子中的语法关系和结构。<br>     在应用上：分词通常在语法分析之前进行，为语法分析提供输入；语法分析则使用分词的结果作为输入，并确定单词之间的依存关系和功能关系：<br>     <strong>分词&#x3D;&gt;语法分析&#x3D;&gt;单词之间的依存关系和功能关系</strong></p><h3 id="解析-语法分析："><a href="#解析-语法分析：" class="headerlink" title="解析&#x2F;语法分析："></a>解析&#x2F;语法分析：</h3><p>这个过程是将数组（词法单元流）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树——抽象语法树。</p><h4 id="抽象语法树："><a href="#抽象语法树：" class="headerlink" title="抽象语法树："></a>抽象语法树：</h4><p>抽象语法树(Abstract Syntax Tree,AST)：以树的形式表示程序的语法结构，其中每个节点代表源代码中的一个语法元素，AST是编译器和代码分析工具的核心组件，由于它的存在得以以结构化的方式来表示和理解源代码，便于更佳有效的进行语法检查和优化。<br>ps：这是一个比较抽象的知识点概念，很难具像化的进行描述。</p><h3 id="代码生成："><a href="#代码生成：" class="headerlink" title="代码生成："></a>代码生成：</h3><p>这个过程是指将AST转换成可执行代码的过程被称为代码生成。与语言以及目标平台等息息相关。<br>简单描述的话，就是有某种方法可以将<code>var a = 2</code>的AST转化为一组机械指令，用来创建一个叫做a的变量（包括分配内存等），并且将一个值储存在a中。<br><strong>因此比起只有三个步骤的语言的编译器而言，JS编译器引擎要复杂的多</strong></p><h3 id="JavaScript编译与其他计算机语言的差异化"><a href="#JavaScript编译与其他计算机语言的差异化" class="headerlink" title="JavaScript编译与其他计算机语言的差异化"></a>JavaScript编译与其他计算机语言的差异化</h3><p>JS引擎不会有大量的时间（相较于其他语言的编译器）进行优化，不同于其他语言，JS的编译过程不是发生在构建之前的。JS的编译大部分情况下发生在代码执行前的几微秒（甚至更短）的时间内。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS及编辑原理&quot;&gt;&lt;a href=&quot;#JS及编辑原理&quot; class=&quot;headerlink&quot; title=&quot;JS及编辑原理&quot;&gt;&lt;/a&gt;JS及编辑原理&lt;/h1&gt;&lt;p&gt;即便大家跟喜欢称JS为“解释性语言”，但是事实上它是一门编译语言。不同于传统的编译语言，它不是提前编</summary>
      
    
    
    
    
    <category term="JavaScript编译原理" scheme="http://example.com/tags/JavaScript%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的搭建</title>
    <link href="http://example.com/2024/03/20/Hexo%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2024/03/20/Hexo%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2024-03-20T07:16:27.000Z</published>
    <updated>2024-07-07T11:47:01.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>最近计划搭建自己的博客，于是在CSDN，或是<a href="https://hexo.io/zh-tw/">hexo官网</a>查询搭建方式，发现各个平台都没有一套完整简洁的方法，而且或多或少都会遇见一些难以解决的问题，因此，整理了这一篇文档以供大家参考，用以使用Hexo来搭建大家自己的博客。<br>Hexo使用Markdown来写文章，几秒时间就可以生成静态网页。</p><h2 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h2><p>Hexo是一个基于Node.js的静态博客框架，与Github结合使用，允许用户通过Github Pages<strong>免费</strong>托管和分享博客内容。<br>博客对于程序员来说，不仅仅是一个分享内容的平台，我们通常将开源项目分享在Github上，将学习心得整理在博客上，这里我整理Hexo的搭建方式也是为了方便大家对于Hexo的建立并且作为我分享的第一个文章。<br>我的师傅对我说过，一个程序员，能够在自己学习的历程中，记录下来笔记，写下心得是相当重要的，因此在他的引导下，我以Hexo为平台，分享记录自己相对重要的笔记以及体会。这里撰写内容使用的语言是Markdown，对于md编辑器通常使用Typora、mweb或者vscode，前两者需要收费才能开通全部功能，而vscode则完全免费使用，但是观感上并不如前两者好看以及好用，但是各个平台对于破解版软件的售卖基本毫无顾虑，所以很简单就能买到破解版软件，但是对于程序员来说版权是一个比较敏感的问题，如果没有经济实力可以使用破解版，如果未来发展成功补票上车来对软件开发团队的敬意其实也不无不可。<br>对于md撰写笔记有很多小指令，我后续会写一篇简短的文章来介绍。</p><h3 id="Hexo的安装前提"><a href="#Hexo的安装前提" class="headerlink" title="Hexo的安装前提"></a>Hexo的安装前提</h3><p>安装Hexo非常简单：<br>    Node.js <em>版本不低于10.13，只要稍微注意就行，一般直接安装最新版本</em><br>    Git 对于程序员是经常使用或者说是必须了解的代码托管平台</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>Github主要是以程序员为主的全球最大的代码托管平台，主要作用是保存程序员编写的软件源代码，对于程序员来说Github绝对不陌生 <del>（如果不知道的，去墙角罚站）</del> ，因此这里就不对Github做过多描述了。<br>想要使用Hexo搭建属于自己的博客需要的前提就是要有自己的Github，并且完成通信。<br>所以本文并不对Github的基本使用做出描述，可能后续会写一些文章作为Github的教程。<br>可以点击本文的超链接跳转到Github官网：<a href="https://github.com/">跳转到Github官网</a></p><h4 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h4><p>Node.js的安装较为简单，并且他为大多数平台提供了官方安装程序。<br><a href="https://nodejs.p2hp.com/download/">Node.js下载链接</a><br>目前node.js官网的下载方式已经相当人性化，可以通过官网提供的安装程序进行安装，个人建议安装LTS版本（稳定版）。<br>按照引导的方式安装完成之后，打开终端，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><p>出现版本号即代表安装成功。</p><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><p>如果上述操作都已经完成，那么可以通过npm即可完成Hexo的安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>结合各个平台在这里出现的问题，我发现这里可能会弹出警告warn缺少权限，那么我们可以在指令前加上sudo，相当于windows中使用管理员权限运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h4 id="步骤一-hexo-init"><a href="#步骤一-hexo-init" class="headerlink" title="步骤一 hexo init"></a>步骤一 hexo init</h4><p>我们可以通过终端，选定想要将博客所需的文件夹创建的位置，对文档的归类整理相当重要，建议每个人都要养成习惯。<br>macos许多操作需要使用终端指令来完成,这里只需要打开想要下载的位置，并且在终端输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;my_blog  //这里文件夹的名字可以自己取，下文都用my_blog指代&gt;</span><br><span class="line">cd my_blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装后，文件下的目录如下所示：<br>_config.yml：网站的配置信息，您可以在此配置大部分的参数。<br>package.json：这里记录了应用程序的信息，对于第三方插件等的应用版本需求等。<br>scaffolds：这是模板文件夹，当创建文章时，Hexo会更需scffolds来创建文件。<br>source：这是资源文件夹，用以存放用户资源（开头命名为 _ (下划线)的文件 &#x2F; 文件夹和隐藏的文件将会被忽略）。<br>themes：主题文件夹，我们可以在官方提供的主题里面挑选自己喜欢的主题，这里由于官网对于Hexo的支持真的可以说成是一坨，不然不会激起我以及我师傅对于Hexo博客的搭建教程，所以大家在应用主题时要注意主题的支持以及需要的第三方插件。</p><h4 id="步骤二-Github"><a href="#步骤二-Github" class="headerlink" title="步骤二 Github"></a>步骤二 Github</h4><p>在Github上创建一个仓库，仓库名为 <strong>账户名.github.io</strong> ，其他为默认选项。</p><h4 id="步骤三-deploy插件"><a href="#步骤三-deploy插件" class="headerlink" title="步骤三 deploy插件"></a>步骤三 deploy插件</h4><p>deploy插件极为重要，必须部署，负责将Hexo生成的静态文件推送到远程服务器，从而实现博客的部署。<br>在博客目录下，敲击命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h5 id="配置deploy"><a href="#配置deploy" class="headerlink" title="配置deploy"></a>配置<code>deploy</code></h5><p>安装完成后需要在_config.yml中启用并且配置deploy插件，以下是一个基本的配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:&lt;repository url&gt;</span><br><span class="line">  branch:&lt;branch&gt;</span><br><span class="line">  message:&lt;commit message&gt;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>type</code>：指定部署类型，通常为<code>git</code>。</li><li><code>repo</code>：指定远程仓库的URL，例如<code>https://github.com/username/username.github.io.git</code>。</li><li><code>branch</code>：指定部署到的分支，对于GitHub Pages，通常是<code>main</code>或<code>master</code>。</li><li><code>message</code>：指定提交信息，可以是自定义的消息或自动生成的消息。</li></ul><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>完成以上配置后，可以使用如下命令来使用Hexo博客：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>这个命令会触发<code>deploy</code>插件，将生成的静态文件推送到指定的远程仓库。</p><p><em>不得不说的注意事项：</em></p><ul><li>在部署之前，请确保已经安装了Git，并且配置了正确的SSH密钥。</li><li>如果遇到部署失败的情况，可以检查<code>deploy</code>插件的配置是否正确，或者查看Hexo输出的错误信息进行排查。</li><li>如果需要部署到多个远程仓库，可以在<code>_config.yml</code>文件中配置多个<code>deploy</code>插件实例。</li></ul><p><em>好了，你已经学会了初步制作一个属于自己的博客了，下面开始尝试吧</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo&quot;&gt;&lt;a href=&quot;#Hexo&quot; class=&quot;headerlink&quot; title=&quot;Hexo&quot;&gt;&lt;/a&gt;Hexo&lt;/h1&gt;&lt;p&gt;最近计划搭建自己的博客，于是在CSDN，或是&lt;a href=&quot;https://hexo.io/zh-tw/&quot;&gt;hexo官网&lt;</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
